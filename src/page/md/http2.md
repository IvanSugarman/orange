## HTTP基本优化
影响一个HTTP请求的主要因素包括**带宽**与**延迟**
- 带宽：现在的网络基础已经得到极大提升，带宽已经不成为影响http性能的主要问题。
- 延迟
    1. 浏览器阻塞：浏览器会因为一些原因，阻塞请求的最大连接数。这点因为不同浏览器上具有相对的差异。当超过浏览器最大连接数，请求就会被阻塞。
    2. DNS查询：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
    3. 建立连接：HTTP请求是基于TCP协议的，每次请求时都要起码第三次握手才能传递报文，达到真正的建立连接。但是这些**连接无法复用**并且需要经历**慢启动（一开始浏览器会限制http传输的速度，如果数据成功传输，会随着时间的推移提高传输的速度。）**。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
    

## HTTP1/1做的优化
http1.1作为长时间以来使用最广泛的http协议，与1.0相比做的优化在于以下几个方面。
1. 缓存处理，在HTTP1.0中主要使用header里的**If-Modified-Since,Expires**来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如**Entity tag，If-Unmodified-Since, If-Match,** **If-None-Match**等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，**HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206**（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. 错误通知的管理，在HTTP1.1中**新增了24个错误状态响应码**，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，**请求消息中的URL并没有传递主机名**（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。**HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误**（400 Bad Request）。
5. 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，**在一个TCP连接上可以传送多个HTTP请求和响应**，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启**Connection： keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

## 当前存在的问题
- HTTP1.x在传输数据时，每次都需要重新建立连接。增加了大量的延迟时间，这点在移动端最为突出。
- HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。
- HTTP1.x在使用时，**header里携带的内容过大**，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。
-  虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是**keep-alive使用多了同样会给服务端带来大量的性能压力**，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。


## HTTPS
简单来说,https就是安全版的http。其与http的一些区别如下。
- https需要CA证书。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在**SSL/TLS**之上，**SSL/TLS运行在TCP之上**，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，**前者是80，后者是443**。
- HTTPS可以有效的防止运营商劫持

![image](http://jbcdn2.b0.upaiyun.com/2016/08/e6c41c02a9b4a29a7ee504ea7587de55.png)


值得注意的是，HTTPS会降低用户的访问速度，SSL握手，HTTPS 对速度会有一定程度的降低。相比于HTTPS降低访问速度，更需要关注的是服务端CPU的压力，HTTPS中大量的秘钥计算会消耗大量的CPU资源。

## HTTP2新特性
#### 多路复用
多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。

在HTTP1.x中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。

HTTP2.0可以很容易的去实现多流并行而不用去建立多个TCP连接。在2中把http协议的通信**基本单位缩小为一个个帧**，这些帧并行的在同一个tcp请求中进行数据的**双向交换**。

#### 二进制分帧
http2.0在应用层（HTTP/2）与传输层（TCP/UDP）之间增加了一个**二进制分帧层**，在这个层中，http2将所有信息转化为更小的消息与帧，并采用二进制编码。在http1.1中的Header部分会放在**header frame**中，相应的request body放在**data frame**中。http2.0都在一个连接上完成。这个连接可以承载任意的双向数据流，更有效的使用TCP连接。

#### 首部压缩
HTTP1.1并不支持首部压缩。为此SDPY和HTTP2应运而生。SPDY使用通用的DEFLATE算法。HTTP2.0使用专门为压缩设计的HPACK算法。

#### 服务端推送
在HTTP2.0中，服务器可以对客户端的一个请求返回多个响应。如果一个请求由你主页发起。服务器很可能会响应**主页内容,logo与样式表**。这就相当于在一个HTML中集合了所有的资源。也让遵循同源的基础上，不同页面之间共享缓存资源成为了可能。

## HPACK
简单的说，HPACK 使用2个索引表(静态索引表和动态索引表)来把头部映射到索引值，并对**不存在的头部**使用** huffman 编码**，并动态缓存到索引，从而达到压缩头部的效果。
#### 静态索引表
预先定义在RFC中的头部，只要发送的值符合静态表时，直接使用索引替换。很大程度压缩了头部的大小。如果遇到非静态表的值，使用动态表。

#### 动态索引表
动态索引表是一个先进先出序列维护的有大小限制的表。在FIFO中，最新进入的索引为最小值，最老的索引为最大值。
- 动态空间表的大小: (每个header的字节数 + 32) * 键值对个数
- 动态空间表的最大字节数由HTTP/2中SETTING帧的SETTINGS_HEADER_TABLE_SIZE常量控制

（32指为了头所占用的额外空间和计算头被引用次数而估计的值。）

动态表管理大小的方式主要通过以下两种
1. 压缩方用上述方式要求动态修改动态表的大小。在这种情况下，如果新的值更小，并且当前大小超过了新值，就会从旧至新，不断的删除头，直到小于等于新的大小。

2. 收到或发出一个新的头部，会触发插入和可能的删除操作。新的值被插到队首，一样从旧到新删除直到空间占用小于等于最大值。那么在这种情况下，如果新来的头比最大值还要大，就等于变相的清除了动态表。

#### 索引空间
索引空间就是静态索引表与动态索引表组成的头部与索引的隐射关系。假设静态表的空间大小是30，则索引空间从1-30位静态表，之后根据动态表的大小，决定索引空间的总大小。
