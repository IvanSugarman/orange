## 背景
在http1.1中，首部字段是不进行压缩的。因此，当成百上千个请求时，这些请求冗余的首部字段会不必要的消耗带宽。造成可测量的网络延时。SDPY曾经用DEFLATE格式压缩头部解决这种冗余，但是其暴露了CRIME攻击的风险。

HPACK是一种新的压缩机制，消除了冗余的首部字段，限制了对已知安全攻击的脆弱性，并却具有在受限环境中使用的有限内存要求。它没有定义可扩展机制，只能定义完全的替代品更改其格式。

## 格式
首部字段列表视为可包含重复对的名-值对的有序集合。名字和值被认为是不透明的字节序列，并且头部字段的顺序在压缩和解压后被保留。

编码通过将头部字段映射到索引值的头部字段表来获知。这些头部字段表可以随着新头部字段的编码和解码而增量地更新。

字面量值直接编码或使用一个静态Huffman码。

编码器负责决定将哪些头部字段作为新条目插入头部字段表。解码器执行由编码器规定的对头部字段表的修改，及重建头部字段列表的过程。这使解码器保持简单，并能与各种编码器的互操作。

## 术语
- 头部字段： key-value。不透明的字节序列
- 动态表： 将存储的头部字段和索引值关联起来的表。动态的，特定于编码或者上下文
- 静态表： 静态地将频繁出现的头部字段与索引值关联起来的表。有序的，只读的，总是可访问的。且可以在所有的编码或解码上下文间共享的。
- 头部列表： 联合编码的头部字段可出现重复的有序头部字段集合。一个HTTP/2 HEADER 中包含的完整的头部字段列表是一个头部列表。
- 头部字段表示： 头部字段可以以字面量或索引的编码形式表示
- 头部块： 头部字段表示的有序列表，当解码时，产生完整的头部列表。

## 压缩过程
HPACK保留头部列表中头部字段的顺序。

- 编码器： 根据头部字段在原始头部列表中的顺序在头部块中对头部字段表示进行排序
- 解码器： 根据头部字段表示在头部块中的顺序在解码的头部列表中对头部字段进行排序。

解压缩头部块的时候，解码器只需维护作为解码上下文。

当被用于双向通信时，比如在HTTP中，编码和解码动态表完全独立地由一端维护，比如，请求和响应的动态表是分开的。

#### 索引表
通过两个表将索引与头部字段关联，静态表是预定义的，包含常用的字段。动态表是动态的，可被编码器用于在编码的头部列表中重复地索引头部字段。两个表组合起来，用于定义单个索引值的地址空间。

```
<----------  Index Address Space ---------->
<-- Static  Table -->  <-- Dynamic Table -->
+---+-----------+---+  +---+-----------+---+
| 1 |    ...    | s |  |s+1|    ...    |s+k|
+---+-----------+---+  +---+-----------+---+
                       ^                   |
                       |                   V
                Insertion Point      Dropping Point

```

#### 静态表
预定义的头部静态列表

#### 动态表
动态表由以FIFO顺序维护的头部字段列表组成。动态表中第一个且最新的条目索引值最低，动态表最旧的条目索引值最高。

每个动态表只针对一个连接，每个连接的压缩解压缩的上下文有且仅有一个动态表。

- 动态表本来是空的，条目随着解压头部块过程增加
- 动态表可以包含重复的条目
- 编码器决定如何更新动态表，并因此可以控制动态表使用多少内存。
- 处理 头部字段表示时更新动态表

##### 动态表管理
动态表条目大小是它名字的字节长度及它值的字节长度的总和，外加32(预估开销，如果条目结构使用两个64位的指针引用条目的名字和值，及两个64位整数来计数引用了名字和值的引用数目，这将有32字节的开销。

任何条目的大小使用未应用Huffman编码条件下，它的名字和值的长度来计算。

##### 最大表大小
通过SETTINGS_HEADER_TABLE_SIZE管理。无论何时动态表最大大小减小，将条目从动态表的结尾处逐出，直到动态表的大小小于或等于最大大小。

## 头部块
解码器顺序地处理头部块来重建原始的头部列表。一旦头部字段被解码并加进了重建的头部列表，它就不能被移除了。被加进头部列表的头部字段可以被安全地传给应用程序。

- 索引的表示：静态表或动态表中被引用的条目对应的头部字段被加到解码的头部列表。
- 不加进动态表： 头部字段被加到解码的头部列表
- 加进动态表： 头部字段被加到解码的头部列表。头部字段被插入动态表的起始位置。这种插入可能导致动态表中之前的条目被逐出

## 原始数据类型表示
HPACK算法表示的对象，主要有原始数据类型的整型值和字符串，头部字段，以及头部字段列表。

HPACK编码使用两种原始数据类型：无符号的变长整数和字节串

#### 整数
整数用于表示
- 名字索引
- 头部字段索引
- 字符串长度。

整数由两部分表示
- 填满当前字节的前缀
- 在前缀不足以表示整数时的一个可选字节列表

为HPACK希望每一个整数的表示能够从某个8比特位字节(octet，下文将其简写为"字节")中的任何一个比特位开始，但总是要在某个字节的最后一个比特位结束。

如果小于前缀，则直接通过前缀表示。
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| ? | ? | ? |       Value       |
+---+---+---+-------------------+

```
如果大于前缀，则前缀表示2^n-1的数，剩下的数通过剩余帧表示，剩余帧中首位通过0与1表示是否是结束。

```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| ? | ? | ? | 1   1   1   1   1 |
+---+---+---+-------------------+
| 1 |    Value-(2^N-1) LSB      |
+---+---------------------------+
               ...
+---+---------------------------+
| 0 |    Value-(2^N-1) MSB      |
+---+---------------------------+
```

要由字节列表解码整数值，首先需要将列表中的字节顺序反过来。然后，移除每个字节的最高有效位。连接字节的剩余位，再将结果加2^N-1获得整数值。

如果我们用3个bit标识前置位
```
5 = ?????101
(101b = 5)
8 = ?????111 00000001
(111b + 1 = 8)
135 = 7 + 128 = ?????111 10000000 00000001
(111b + 0 + 128 * 1 = 135)
```

#### 字符串
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| H |    String Length (7+)     |
+---+---------------------------+
|  String Data (Length octets)  |
+-------------------------------+
```

- H: 表示是否是huffman编码，1为是
- StringLength: 表示随后跟随的字符串的长度，用上述的整数编码方式编码
- StringData： 如果是 huffman 编码，则使用 huffman 编码后的字符串，否则就是原始串。

##### huffman编码
根据字符出现的概率重新编排字符的二进制代码，从而压缩概率高的字符串进而压缩整个串的长度。这里的 huffman 编码是静态的，是根据过去大量的 Http 头的数据从而选出的编码方案。

## 二进制编码压缩

#### 已被索引的头部
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
```

第一个bit为1，随后紧跟一个 无整数的编码表示 Index，即为静态表或者是动态表中的索引值。

#### name在索引，value不在索引且允许保存
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

第一个字节的前两个bit为01，随后无符号整数编码Index表示name的索引。下面紧随一个字面字符串的编码，表示value 。这个 Header 会被两端都加入动态表中。

#### name和value都没被索引而且允许保存
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```
第一个字节为01000000, 然后紧随2个字面字符串的编码表示。
这个 Header 会被两端都加入动态表中。

#### name被索引， value未索引且不保存
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

#### name与value都未被索引且不保存
```
    0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

#### name在索引表中， value不在，且绝对不允许被索引
```
0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```
这个和之前仅仅在于，中间是否通过了代理。如果没有代理那么表现是一致的。如果中间通过了代理，协议要求代理必须原样转发这个 Header 的编码，不允许做任何修改，这个暗示中间的代理这个字面值是故意不压缩的，比如为了敏感数据的安全等。而之前则允许代理重新编码等。

#### name 和 value 都不在索引表中，且绝对不允许被索引
```
 0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

#### 修改动态表的大小
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
```

## 栗子
有一个编码的header如下
```
:method: GET
:scheme: http
:path: /
:authority: www.example.com
```

已被索引的头部：
:method: GET -> 静态表Index = 2 -> 10000010 -> 82
:scheme: http -> 静态表Index = 6 -> 10000110 -> 86 
:path: / -> 静态表Index = 4 -> 10000100 -> 84
:authority(name被索引，值未) -> 静态表 = 1 -> 01000001 -> 41
之后一个字符串类型的解码解析:authority对应的value，使用huffman编码，其字符串长度为12所以得到 -> 10001100 = 8c
接着解析12个字节为 huffman 编码后的字符f1e3 c2e5 f23a 6ba0 ab90 f4ff

编码之后16进制如下
```
8286 8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 ff     
```